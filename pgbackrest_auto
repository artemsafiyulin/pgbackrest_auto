#!/bin/bash
# Author: Vitaliy Kukharik (vitabaks@gmail.com)
# Title: /usr/bin/pgbackrest_auto - Automatic Restore and Validate for physical and logical database corruption

# Dependencies: OS Debian/Ubuntu, PostgreSQL >= 9.4, pgbackrest >= 2.01, "jq" package;
# for "--checksums" (and "--checkdb"): postgresql-<version>-pg-checksums package (if PostgreSQL version <= 11)
# for "--amcheck" (and "--checkdb"): postgresql-<version>-amcheck package (if PostgreSQL version <= 10)
# for "--report": sendemail
# Run as user: postgres

ver="1.4.0"

# variables for function "sendmail()"
smtp_server="10.128.64.5:25"
mail_from="backuper@my-domain.com"
mail_to="dba@my-domain.com"
attach_report=false  # or 'true'

# Send report to mail address
function sendmail(){
    SMTP="${smtp_server}"
    EMAIL="${mail_to}"
    SUBJECT="postgres restore report for '${FROM}': $(date +%Y-%m-%d) (auto-generated)"
    MAIL_FROM="${mail_from}"

    # send mail
    if [ "$attach_report" = true ]; then
        sendemail -v -o message-content-type=text -o message-file="${log}" -f "${MAIL_FROM}" -t "${EMAIL}" -u "${SUBJECT}" -s "${SMTP}" -a "${log}"
    else
        sendemail -v -o message-content-type=text -o message-file="${log}" -f "${MAIL_FROM}" -t "${EMAIL}" -u "${SUBJECT}" -s "${SMTP}"
    fi
}

function info(){
    msg="$1"
    echo -e "$(date "+%F %T") INFO: $msg"
    logger -p user.notice -t "$(basename "$0")" "$msg"
}
function warnmsg(){
    msg="$1"
    echo -e "$(date "+%F %T") \e[33mWARN:\e[0m $msg"
    logger -p user.notice -t "$(basename "$0")" "$msg"
    return 1
}
function error(){
    msg="$1"
    echo -e "$(date "+%F %T") \e[91mERROR:\e[0m $msg"
    logger -p user.error -t "$(basename "$0")" "$msg"
    # sendmail
    if [[ "${REPORT}" = "yes" ]]; then sendmail; fi
    # remove lock file
    if [ -f "${lock}" ]; then rm "${lock}"; fi
    exit 1
}


while getopts ":-:" optchar; do
    [[ "${optchar}" == "-" ]] || continue
    case "${OPTARG}" in
        from=* )
            FROM=${OPTARG#*=}
            ;;
        to=* )
            TO=${OPTARG#*=}
            ;;
        datname=* )
            DATNAME=${OPTARG#*=}
            ;;
        backup-set=* )
            BACKUPSET=${OPTARG#*=}
            ;;
        recovery-type=* )
            RECOVERYTYPE=${OPTARG#*=}
            ;;
        recovery-target=* )
            RECOVERYTARGET=${OPTARG#*=}
            ;;
        backup-host=* )
            BACKUPHOST=${OPTARG#*=}
            ;;
        pgver=* )
            PGVER=${OPTARG#*=}
            ;;
        dummy-dump )
            DUMMYDUMP=yes
            ;;
        checksums )
            CHECKSUMS=yes
            ;;
        amcheck )
            AMCHECK=yes
            ;;
        checkdb )
            CHECKDB=yes
            ;;
        clear )
            CLEAR=yes
            ;;
        report )
            REPORT=yes
            ;;
        norestore )
            NORESTORE=yes
            ;;
    esac
done


function help(){
echo -e "
Automatic Restore and Validate for physical and logical database corruption

Support three types of restore:
        1) Restore last backup  (recovery to earliest consistent point) [default]
        2) Restore latest       (recovery to the end of the archive stream)
        3) Restore to the point (recovery to restore point)

Important: Run on the nodes on which you want to restore the backup

Usage: $0 --from=STANZANAME --to=DATA_DIRECTORY [ --datname=DATABASE [...] ] [ --recovery-type=( default | immediate | time ) ] [ --recovery-target=TIMELINE  [ --backup-set=SET ] [ --backup-host=HOST ] [ --pgver= ] [ --checkdb ] [ --clear ] [ --report ] ]


--from=STANZANAME
        Stanza from which you need to restore from a backup

--to=DATA_DIRECTORY
        PostgreSQL Data directory Path to restore from a backup
        a PostgreSQL database cluster (PGDATA) will be automatically created (initdb) if it does not exist
        Example: /bkpdata/rst/app-db

--datname=DATABASE [...]
        Database name to be restored (After this you MUST drop other databases)
        Note that built-in databases (template0, template1, and postgres) are always restored.
        To be restore more than one database specify them in brackets separated by spaces.
        Example: --datname=\"db1 db2\"

--recovery-type=TYPE
        immediate - recover only until the database becomes consistent           (Type 1. Restore last backup)  [default]
        default   - recover to the end of the archive stream                     (Type 2. Restore latest)
        time      - recover to the time specified in --recovery-target           (Type 3. Restore to the point)

--recovery-target=TIMELINE
        time - recovery point time. The time stamp up to which recovery will proceed.
        if --recovery-type=time
        Example: \"2022-06-14 09:00:00\"

--backup-set=SET
        If you need to restore not the most recent backup. Example few days ago.
        Get info of backup. Login to pgbackrest server. User postgres
        pgbackrest --stanza=[STANZA NAME] info
        And get it. Example:
                    incr backup: 20220611-000004F_20220614-000003D
        This is the name of SET: 20220611-000004F_20220614-000003D

--backup-host=HOST
        pgBacRest repository ip address (Use SSH Key-Based Authentication)
        localhost [default]

--pgver=VERSION
        PostgreSQL cluster (instance) version [ optional ]
        by default, the PostgreSQL version will be determined from the pgbackrest info

--dummy-dump
        Verify that data can be read out. Check with pg_dump >> /dev/null

--checksums
        Check data checksums

--amcheck
        Validate Indexes (verify the logical consistency of the structure of indexes and heap relations)

--checkdb
        Validate for Physical and Logical Database Corruption (includes: dummy-dump, checksums, amcheck)

--clear
        Clear PostgreSQL Data directory after Restore (the path was specified in the \"--to\" parameter ) [ optional ]

--report
        Send report to mail address

--norestore
        Do not restore a stanza but use an already existing cluster

EXAMPLES:
( example stanza \"app-db\" , backup-host \"localhost\" )

| Restore last backup:

    $0 --from=app-db --to=/bkpdata/rst/app-db

| Restore backup made a few days ago:

    $0 --from=app-db --to=/bkpdata/rst/app-db --backup-set=20220611-000004F_20220614-000003D

| Restore backup made a few days ago and pick time:

    $0 --from=app-db --to=/bkpdata/rst/app-db --backup-set=20220611-000004F_20220614-000003D --recovery-type=time --recovery-target=\"2022-06-14 09:00:00\"

| Restore backup made a few days ago and pick time. And we have restore only one database with the name \"app_db\":

    $0 --from=app-db --to=/bkpdata/rst/app-db --backup-set=20220611-000004F_20220614-000003D --recovery-type=time --recovery-target=\"2022-06-14 09:00:00\" --datname=app_db

| Restore and Validate of databases:

    $0 --from=app-db --to=/bkpdata/rst/app-db --checkdb
"
exit
}
[ "$1" = "-h" ] || [ "$1" = "--help" ] || [ "$1" = "help" ] && help
if [ "$1" = "-v" ] || [ "$1" = "--version" ] || [ "$1" = "version" ]; then echo "$0 version ${ver}" && exit; fi

USR=$(whoami)
if [ "$USR" != 'postgres' ]; then
    error "$0 must be run as postgres"
fi

# check if sendemail exists
if [[ "${REPORT}" = "yes" ]]; then
    if ! command -v sendemail &> /dev/null
    then
        warnmsg "sendemail could not be found. Please install the sendemail package"
        exit
    fi
fi

# check if jq exists
if ! command -v jq &> /dev/null
then
    warnmsg "jq could not be found. Please install the jq package"
    exit
fi

# Log file
log="/var/log/pgbackrest/pgbackrest_auto_${FROM}.log"
# File contain status of restore for zabbix monitoring
zbx_status_file="/var/lib/zabbix/zbx_pgbackrest_auto_${FROM}.data"
# Lock file
lock="/tmp/pgbackrest_auto_${FROM}.lock"
exec 9>"${lock}"
flock -n 9 || exit

[[ -z "${FROM}" ]] && error "--from is missing"
[[ -z "${TO}" ]] && error "--to is missing"
[[ -z $RECOVERYTYPE && -n $RECOVERYTARGET ]] && error "--recovery-type is missing"
if [[ $RECOVERYTYPE != default ]]; then
    [[ -n $RECOVERYTYPE && -z $RECOVERYTARGET ]] && error "--recovery-target is missing"
fi
# default recovery-type = immediate
if [[ -z $RECOVERYTYPE ]]; then RECOVERYTYPE="immediate"; fi

[[ $RECOVERYTYPE = immediate || $RECOVERYTYPE = default || $RECOVERYTYPE = time ]] || error "--recovery-type=( immediate | default | time )"
[[ $RECOVERYTYPE = default && -n $RECOVERYTARGET ]] && error "Not use --recovery-type=default with --recovery-target"
if [[ -n $DATNAME && -n $CHECKDB ]]; then error "Not use --checkdb with --datname. It work with only Full PostgreSQL Restore"; fi

# PostgreSQL
PG_INSTANCE=$(bash -c "echo ${TO} | sed -e 's|.*/||g'")
if [[ -z $PGVER ]]; then
    # get the postgres version from stanza
    PGVER=$(pgbackrest info --stanza="${FROM}" --output=json | jq -r '.[].db[-1]."version"')
    if [[ "$PGVER" = "null" ]]; then
        error "could not determine the postgres version using \"pgbackrest info --stanza=${FROM}\""
    fi
fi

# check if pg_checksums exists (for PostgreSQL version <= 11)
if [[ "$PGVER" -le "11" ]] && [[ "${CHECKSUMS}" = "yes" ]] || [[ "${CHECKDB}" = "yes" ]]; then
    if ! command -v /usr/lib/postgresql/"${PGVER}"/bin/pg_checksums &> /dev/null
    then
        warnmsg "pg_checksums command not be found. Please install the postgresql-$PGVER-pg-checksums package"
        exit
    fi
fi

# check if a directory exists
if [[ ! -d "${TO}" ]]; then
    if ! mkdir -p "$TO"; then
        warnmsg "cannot create directory $TO"
        exit
    fi
fi

# initdb if the directory ("--to") is empty
if [[ -z "$(ls -A "${TO}")" ]]; then
    # check if postgresql package exists
    if ! dpkg -l | grep -q postgresql-"${PGVER}"; then
        warnmsg "the PostgreSQL version ${PGVER} could not be found. Please install the postgresql-${PGVER} package"
        exit
    fi
    # pg_createcluster
    if ! pg_createcluster "${PGVER}" "${PG_INSTANCE}" -D "${TO}" &> /dev/null; then
        warnmsg "initdb error with the command \"pg_createcluster ${PGVER} ${PG_INSTANCE} -D ${TO}\""
        exit
    fi
fi

# Compare DB and filesystem size before restore
# get the database size from the given backup-set or last backup
if [[ -n $BACKUPSET ]]; then
    DBSIZE=$(pgbackrest info --stanza="${FROM}" --output=json | jq -r '.[].backup[] |  select(.label == "${BACKUPSET}") | .info.size')
fi
if [[ -z $BACKUPSET ]]; then
    DBSIZE=$(pgbackrest info --stanza="${FROM}" --output=json | jq -r '.[].backup[-1].info.size')
fi
# check the disk space
DIRSIZE=$(df "$TO" | tail -1 | awk '{print $4}')
if [[ $(( "$DIRSIZE * 1000" )) -le $DBSIZE && "$NORESTORE" != "yes" ]];
then
    error "Not enough disk space for restore to $TO"
fi

# checkdb_mode
if [[ -z $CHECKDB ]]; then 
    [[ "${DUMMYDUMP}" = "yes" ]] && CHECKDB_MODE+="dummy-dump "
    [[ "${CHECKSUMS}" = "yes" ]] && CHECKDB_MODE+="checksums "
    [[ "${AMCHECK}" = "yes" ]] && CHECKDB_MODE+="amcheck "
    if [[ -z $DUMMYDUMP && -z $CHECKSUMS && -z $AMCHECK ]]; then CHECKDB_MODE="No"; fi
else CHECKDB_MODE="yes"
fi

# Variables for function "pgbackrest_exec()"
if [[ -z $BACKUPHOST ]]; then BACKUPHOST="localhost"; fi
backup_conf=/tmp/pgbackrest_auto.conf
if [ ! -f $backup_conf ]; then touch $backup_conf; fi
if [[ $PGVER = 9.4 || $PGVER = 94 ]]; then
    recovery_opt="pause_at_recovery_target=false"
else
    recovery_opt="recovery_target_action=promote"
fi

# restore_type_msg
if [[ -z $DATNAME && $RECOVERYTYPE = time ]]; then
    restore_type_msg="Full PostgreSQL Restore with Point-in-Time"
elif [[ -z $DATNAME ]]; then
    restore_type_msg="Full PostgreSQL Restore"
elif [[ -n $DATNAME && $RECOVERYTYPE = time ]]; then
    restore_type_msg="Partial PostgreSQL Restore with Point-in-Time"
elif [[ -n $DATNAME ]]; then
    restore_type_msg="Partial PostgreSQL Restore"
fi


function sigterm_handler(){
    info "Recieved QUIT|TERM|INT signal"
    error "Clean up and exit"
}

trap sigterm_handler QUIT TERM INT

function check_errcode(){
    # ARG: "error message"
    [[ $? -ne 0 ]] && error "${1}"
}

function check_mistake_run(){
    if [[ -n "${TO}" ]]; then
        warnmsg "Restoring to ${TO} Waiting 30 seconds. The directory will be overwritten. If mistake, press ^C"
        sleep 30s
    fi
}

function pg_port_pick(){
    if [[ -f /etc/postgresql/"${PGVER}"/"${PG_INSTANCE}"/postgresql.conf ]]; then
        PGPORT=$(sed -n 's/port.*=.*\([0-9]\{4\}\).*/\1/p' /etc/postgresql/"${PGVER}"/"${PG_INSTANCE}"/postgresql.conf | tail -1)
    else
        error "port not found or missing /etc/postgresql/${PGVER}/${PG_INSTANCE}/postgresql.conf file"
    fi
}

function cycle_simple(){
    # ARG: command
    # Assign variable 'status' = "ok" or "er"
    status=
    cmd=$1
    attempt=1
    limit=3600
    while [[ $attempt -le $limit ]]; do
        info "attempt: ${attempt}/${limit}"
        $cmd
        if [[ "$status" = "ok" ]]; then
            # Ready to work
            break
        elif [[ "$status" = "er" ]]; then
            error "exit"
        fi
        ((attempt++))
	sleep 1s
    done

    [[ $attempt -ge $limit && $status != ok ]] && error "attempt limit exceeded"
}

function pg_stop_check(){
    sleep=10
    # Use with function cycle_simple
    info "PostgreSQL check status"
    /usr/bin/pg_ctlcluster "${PGVER}" "${PG_INSTANCE}" status &> /dev/null
    code=$?
    if [[ $code -eq 3 ]]; then
        info "PostgreSQL instance ${PG_INSTANCE} not running"
        status=ok
    elif [[ $code -eq 0 ]]; then
        info "Wait PostgreSQL instance ${PG_INSTANCE} stop: wait ${sleep}s"
        sleep ${sleep}s
    elif [[ $code -eq 4 ]]; then
        info "${TO} is not a database cluster directory. May be its clean."
        status=ok
    else
        warnmsg "PostgreSQL check failed"
        status=er
    fi
}

function pg_stop(){
    /usr/bin/pg_ctlcluster "${PGVER}" "${PG_INSTANCE}" status &> /dev/null
    code=$?
    if [[ $code -eq 0 ]]; then
        info "PostgreSQL stop"
        if /usr/bin/pg_ctlcluster "${PGVER}" "${PG_INSTANCE}" stop -m fast &> /dev/null
        then
            info "PostgreSQL instance ${PG_INSTANCE} stopped"
        else
            warnmsg "PostgreSQL instance ${PG_INSTANCE} stop failed"
        fi
    fi
}

function pgisready(){
    if pg_isready -qp "${PGPORT}"
    then
        info "PostgreSQL instance ${PG_INSTANCE} started and accepting connections"
        status=ok
        return 0
    else
        warnmsg "PostgreSQL instance ${PG_INSTANCE} no response"
        return 1
    fi
}

function pg_start(){
    info "PostgreSQL start"
    if ! /usr/bin/pg_ctlcluster "${PGVER}" "${PG_INSTANCE}" start &> /dev/null
    then
        error "PostgreSQL instance ${PG_INSTANCE} start failed"
    else
        pgisready 1> /dev/null
    fi
}

function pgbackrest_exec(){
    [[ -n "${BACKUPSET}" ]] && pgbackrest_opt="--set=${BACKUPSET}"
    [[ -n "${DATNAME}" ]] && for db in ${DATNAME}; do pgbackrest_opt+=" --db-include=${db}"; done
    if [[ "${RECOVERYTYPE}" = "default" || "${RECOVERYTYPE}" = "time" ]]; then
        [[ -n "${RECOVERYTYPE}" ]] && pgbackrest_opt+=" --type=${RECOVERYTYPE}"
        [[ -n "${RECOVERYTARGET}" ]] && pgbackrest_opt+=" --target=\"${RECOVERYTARGET}\""
    else
    pgbackrest_opt+=" --type=immediate"
    fi
    # tablespace-map-all=${TO}/remapped_tablespaces
    mkdir -p "${TO}"/remapped_tablespaces
    # -- repo1-path
    if [[ -f /etc/pgbackrest.conf ]]; then grep -q "repo1-path" /etc/pgbackrest.conf && pgbackrest_opt+=" --$(bash -c "grep \"repo1-path=\" /etc/pgbackrest.conf")"; fi
    # --
        info "Restore from backup started. Type: $restore_type_msg"
        detail_rst_log="/var/log/pgbackrest/$FROM-restore.log"
        if [ -f "${detail_rst_log}" ]; then info "See detailed log in the file ${detail_rst_log}"; fi
    # execute pgbackrest
    echo "pgbackrest --config=${backup_conf} --repo1-host=${BACKUPHOST} --repo1-host-user=postgres --stanza=${FROM} --pg1-path=${TO} ${pgbackrest_opt} --delta restore --process-max=4 --log-level-console=error --log-level-file=detail --recovery-option=${recovery_opt} --tablespace-map-all=${TO}/remapped_tablespaces"
    if bash -c "pgbackrest --config=${backup_conf} --repo1-host=${BACKUPHOST} --repo1-host-user=postgres --stanza=${FROM} --pg1-path=${TO} ${pgbackrest_opt} --delta restore --process-max=4 --log-level-console=error --log-level-file=detail --recovery-option=${recovery_opt} --tablespace-map-all=${TO}/remapped_tablespaces"
    then
        info "Restore from backup done"
        sed -i 's/Restore_from_backup=0/Restore_from_backup=1/g' "${zbx_status_file}"
    else
        error "Restore from backup failed"
    fi
}

function pg_info_replay(){
    if [[ "${RECOVERYTYPE}" = "time" ]]; then
        info "RECOVERYTYPE time"
        result=$(psql -p "${PGPORT}" -tAXc "SELECT pg_last_xact_replay_timestamp(), '${RECOVERYTARGET}' - pg_last_xact_replay_timestamp()")
    else
        result=$(psql -p "${PGPORT}" -tAXc "SELECT pg_last_xact_replay_timestamp()")
    fi
    while IFS='|' read -r replay_timestamp left_timestamp; do
        if [[ -n "${left_timestamp}" ]]; then
            info "Replayed: ${replay_timestamp} Left: ${left_timestamp}"
        else
            info "Replayed: ${replay_timestamp}"
        fi
    done <<< "${result}"
}

function pg_check_recovery(){
    state=$(psql -p "${PGPORT}" -tAXc 'SELECT pg_is_in_recovery()') 2>/dev/null
    pg_info_replay
    # Is the restore complete? YES
    if [ "$state" = "f" ]; then
        recovery=ok
    # Is the restore complete? No
    elif [ "$state" = "t" ]; then
        sleep 10
    else
    # Is everything all right? check connection with PostgreSQL
        pgisready 1> /dev/null || check_errcode "exit"
        recovery=er
    fi
}

# verify that data can be read out. Check with pg_dump >> /dev/null
function dummy_dump(){
    if ! pgisready 1> /dev/null; then pg_start cycle_simple pgisready; fi
    sed -i 's/Data_validation=0/Data_validation=1/g' "${zbx_status_file}"
    databases=$(bash -c "psql -p ${PGPORT} -tAXc \"select datname from pg_database where not datistemplate\"")
        for db in $databases; do
            info "Start data validation for database $db"
            if pgisready 1> /dev/null; then
                info "... starting pg_dump -p ${PGPORT} -d $db >> /dev/null"
                if ! /usr/lib/postgresql/"${PGVER}"/bin/pg_dump -p "${PGPORT}" -d "$db" >> /dev/null
                then
                    error "Data validation in the database $db - Failed"
                    sed -i 's/Data_validation=1/Data_validation=0/g' "${zbx_status_file}"
                else
                    info "Data validation in the database $db - Successful"
                fi
            fi
        done
}

# checksums - check data checksums
function pg_checksums(){
    if pgisready 1> /dev/null; then pg_stop cycle_simple pg_stop_check; fi
    info "pg_checksums: starting data checksums validation"
    sed -i 's/PG_checksums_validation=0/PG_checksums_validation=1/g' "${zbx_status_file}"
    pg_checksums_result=$(/usr/lib/postgresql/"${PGVER}"/bin/pg_checksums -c -D "${TO}" | grep "Bad checksums")
    if [[ $pg_checksums_result != "Bad checksums:  0" ]]
    then
        warnmsg "pg_checksums: data checksums validation result: $pg_checksums_result"
        sed -i 's/PG_checksums_validation=1/PG_checksums_validation=0/g' "${zbx_status_file}"
        error "pg_checksums: data checksums validation - Failed"
    else
        info "pg_checksums: data checksums validation - Successful"
    fi
}

# amcheck CREATE EXTENSION if not exists
function amcheck_exists(){
    if [ "$PGVER" -le "10" ]; then
        extension='amcheck_next'
    else
        extension='amcheck'
    fi
    if ! psql -v "ON_ERROR_STOP" -p "${PGPORT}" -U postgres -d "$db_name" -tAXc "CREATE EXTENSION if not exists $extension" &> /dev/null
    then
        error "CREATE EXTENSION $extension failed"
    fi
}

# amcheck - verify the logical consistency of the structure of PostgreSQL B-Tree indexes
function amcheck(){
    if ! pgisready 1> /dev/null; then pg_start cycle_simple pgisready; fi
    sed -i 's/Amcheck_validation=0/Amcheck_validation=1/g' "${zbx_status_file}"
    databases=$(bash -c "psql -p ${PGPORT} -tAXc \"select datname from pg_database where not datistemplate\"")
    for db_name in $databases; do
        if pgisready 1> /dev/null; then
            if amcheck_exists; then
                info "amcheck: verify the logical consistency of the structure of indexes and heap relations in the database $db_name"
                indexes=$(psql -p "${PGPORT}" -d "$db_name" -tXAc "SELECT quote_ident(n.nspname)||'.'||quote_ident(c.relname) FROM pg_index i JOIN pg_opclass op ON i.indclass[0] = op.oid JOIN pg_am am ON op.opcmethod = am.oid JOIN pg_class c ON i.indexrelid = c.oid JOIN pg_namespace n ON c.relnamespace = n.oid WHERE am.amname = 'btree' AND n.nspname NOT IN ('pg_catalog', 'pg_toast') AND c.relpersistence != 't' AND c.relkind = 'i' AND i.indisready AND i.indisvalid")
                for index in $indexes; do
                    # info "amcheck: verify the logical consistency of the structure of index ${index}"
                    if ! psql -v ON_ERROR_STOP=on -p "${PGPORT}" -d "$db_name" -tAXc "SELECT bt_index_parent_check('${index}')" 1> /dev/null
                    then
                        warnmsg "amcheck: logical validation for index ${index} ( database $db_name ) - Failed"
                        sed -i 's/Amcheck_validation=1/Amcheck_validation=0/g' "${zbx_status_file}"
                    fi
                done
            fi
        fi
    done
}

# determine postgresql parameters from pg_controldata and configure postgresql.conf
function postgresql_conf(){
    # max_connections
    max_connections=$(/usr/lib/postgresql/"${PGVER}"/bin/pg_controldata "${TO}" | grep max_connections | awk '{print $3}')
    sed -i "/max_connections = /c\max_connections = ${max_connections}" /etc/postgresql/"${PGVER}"/"${PG_INSTANCE}"/postgresql.conf
    # max_worker_processes
    max_worker_processes=$(/usr/lib/postgresql/"${PGVER}"/bin/pg_controldata "${TO}" | grep max_worker_processes | awk '{print $3}')
    sed -i "/max_worker_processes = /c\max_worker_processes = ${max_worker_processes}" /etc/postgresql/"${PGVER}"/"${PG_INSTANCE}"/postgresql.conf
    # max_prepared_transactions
    max_prepared_transactions=$(/usr/lib/postgresql/"${PGVER}"/bin/pg_controldata "${TO}" | grep max_prepared_xacts | awk '{print $3}')
    sed -i "/max_prepared_transactions = /c\max_prepared_transactions = ${max_prepared_transactions}" /etc/postgresql/"${PGVER}"/"${PG_INSTANCE}"/postgresql.conf
    # max_locks_per_transaction
    max_locks_per_transaction=$(/usr/lib/postgresql/"${PGVER}"/bin/pg_controldata "${TO}" | grep max_locks_per_xact | awk '{print $3}')
    sed -i "/max_locks_per_transaction = /c\max_locks_per_transaction = ${max_locks_per_transaction}" /etc/postgresql/"${PGVER}"/"${PG_INSTANCE}"/postgresql.conf
}


### MAIN ###
STEP=1
rm -f "${log}"
touch "${log}"
exec &> >(tee -a "${log}")
pg_port_pick
info "[STEP $((STEP++))]: Starting"
# Reset values in zabbix status file before new restore
printf "Restore_from_backup=0\nRestoring_from_archive=0\nData_validation=0\nPG_checksums_validation=0\nAmcheck_validation=0\nResult_status=1" > "${zbx_status_file}"
if [[ "$NORESTORE" = "yes" ]]; then
    info "Starting. Skipping restore."
    info "Starting. Run settings: Log: ${log}"
    info "Starting. Run settings: Lock run: ${lock}"
    info "Starting. PostgreSQL instance: ${PG_INSTANCE}"
    info "Starting. PostgreSQL version: ${PGVER}"
    info "Starting. PostgreSQL port: ${PGPORT}"
    info "Starting. PostgreSQL Database Validation: ${CHECKDB_MODE}"
    if [[ "${CLEAR}" = "yes" ]]; then info "Starting. Clear Data Directory after restore: ${CLEAR}";fi
    info "[STEP $((STEP++))]: PostgreSQL Starting"
    if ! pgisready; then pg_start
    cycle_simple pgisready
    fi
    sed -i 's/Restore_from_backup=0/Restore_from_backup=1/g' "${zbx_status_file}"
    sed -i 's/Restoring_from_archive=0/Restore_from_archive=1/g' "${zbx_status_file}"
else
    info "Starting. Restore Type: ${restore_type_msg} FROM Stanza: ${FROM} --> TO Directory: ${TO}"
    info "Starting. Restore Settings: ${RECOVERYTYPE} ${RECOVERYTARGET} ${BACKUPSET} ${DATNAME}"
    info "Starting. Run settings: Backup host: ${BACKUPHOST}"
    info "Starting. Run settings: Log: ${log}"
    info "Starting. Run settings: Lock run: ${lock}"
    info "Starting. PostgreSQL instance: ${PG_INSTANCE}"
    info "Starting. PostgreSQL version: ${PGVER}"
    info "Starting. PostgreSQL port: ${PGPORT}"
    info "Starting. PostgreSQL Database Validation: ${CHECKDB_MODE}"
    if [[ "${CLEAR}" = "yes" ]]; then info "Starting. Clear Data Directory after restore: ${CLEAR}";fi
    check_mistake_run
    info "[STEP $((STEP++))]: Stopping PostgreSQL"
    pg_stop
    cycle_simple pg_stop_check
    info "[STEP $((STEP++))]: Restoring from backup"
    # Restore from backup
    pgbackrest_exec
    # get postgresql parameters from pg_controldata
    postgresql_conf
    info "[STEP $((STEP++))]: PostgreSQL Starting for recovery"
    pg_start
    cycle_simple pgisready
    info "[STEP $((STEP++))]: PostgreSQL Recovery Checking"
    # Expect recovery result
    while true; do
        info "Checking if restoring from archive is done"
        pg_check_recovery
        if [[ "${recovery}" = "ok" ]]; then
            info "Restoring from archive is done"
            sed -i 's/Restoring_from_archive=0/Restore_from_archive=1/g' "${zbx_status_file}"
            break
        elif [[ "${recovery}" = "er" ]]; then
            warnmsg "Restoring from archive failed"
            pg_stop; check_errcode "exit"
        fi
    done
fi
if [[ "${CHECKDB_MODE}" != "No" ]]; then
    # checksums - check data checksums
    if [[ "${CHECKDB}" = "yes" || "${CHECKSUMS}" = "yes" ]]; then
    info "[STEP $((STEP++))]: Verify data checksums"
    pg_checksums
    else
    sed -i 's/PG_checksums_validation=0/PG_checksums_validation=1/g' "${zbx_status_file}"
    fi
    # verify that data can be read out. Check with pg_dump >> /dev/null
    if [[ "${CHECKDB}" = "yes" || "${DUMMYDUMP}" = "yes" ]]; then
    info "[STEP $((STEP++))]: Verify that data can be read out"
    dummy_dump
    else
    sed -i 's/Data_validation=0/Data_validation=1/g' "${zbx_status_file}"
    fi
    # amcheck - verify the logical consistency of the structure of PostgreSQL B-Tree indexes
    if [[ "${CHECKDB}" = "yes" || "${AMCHECK}" = "yes" ]]; then
    info "[STEP $((STEP++))]: Verify indexes"
    amcheck
    else
    sed -i 's/Amcheck_validation=0/Amcheck_validation=1/g' "${zbx_status_file}"
    fi
fi
# [ optional ] clear data directory
if [[ "${CLEAR}" = "yes" ]]; then
    info "[STEP $((STEP++))]: Stopping PostgreSQL and Clear Data Directory"
    pg_stop
    cycle_simple pg_stop_check
    if [[ $code -eq 3 ]]; then
        pg_dropcluster "${PGVER}" "${PG_INSTANCE}"
    fi
fi
if [[ "${REPORT}" = "yes" ]]; then
    info "[STEP $((STEP++))]: Send report to mail address"
    sendmail
fi

#set result status of restore for zabbix
if grep -q 0 "${zbx_status_file}"; then
    sed -i 's/Result_status=1/Result_status=0/g' "${zbx_status_file}"
fi

# remove lock file
if [ -f "${lock}" ]; then
    rm "${lock}"
fi
info "Finish"

exit
